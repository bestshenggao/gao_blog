---
title: c语言数据类型
date: 2021-12-01
description: 复习c语言类型
---

# 数据类型

## 1 类型总览

char(1) < short(2) < float(4) <=int(4|8) <= double(8)

内存中所占据的大小： 1 个字节到 16 个字节

2 sizeof()

函数是一个静态的函数， sizeof(3) 实际上会检测 3 在内存中所占的字节数，输出为 4。不会对内部的数据进行真实的操作。

## 2 整数

char: 1byte

Short: 2byte

int: 取决于编译器，通常的意义是 1 个字(寄存器一次可以存储的数据 32bit/64bit)

long：取决于编译器，通常的意义是 1 个字(寄存器一次可以存储的数据 32bit/64bit)

long long：8byte

### 2.1 整数的内部表达

计算机内部一切都是二进制。那么如何得到一个 -1 呢？

1 二进制 00000001

0 二进制 00000000

-1 二进制 11111111

111111111 + 00000001 = （1）00000000。高位溢出，剩下全是 0。

所以 11111111 被当做纯二进制看待时，是 255，被当做补码看待时是 -1。

同理，对于 -a, 其补码就是 0-a,实际是 2^n - a，计算方法总结就是，负数的数值部分转化成二进制，然后取反，再加 1。

补码的意义是拿补码和原码可以加出一个溢出的零，计算机中负数是用补码的方式来进行计算的。整数的补码和原码相同。

### 2.2 char 类型

Char 占 1 个字节，数的取值范围为 -128 ~ 127。

-1(1111 1111) + 1(0000 0001) = 0

1(0000 00001) + 127(0111 1111) = (-128)1000 0000 // 发生整数越界

-128(1000 0000) - 1(0000 0001) = 127(0111 1111) // 发生整数越界

1111 1111 当做二进制进行计算是 256,当做补码来进行运算是-1

-128/127 -> 0/-1 -> -128/127 循环过程

### 2.3 格式化输入整数

%d int 按照十进制整数进行输出

%u unsigned 按照无符号整数进行输出

%ld long long 字节数比 int 大

%lu unsigned long long 字节数比 int 大，按照无符号整数尽心输出

%o 按照八进制进行输出

%x 按照十六进制进行输出

```c
#include<stdio.h>
int main() {
    char c = -1;
    int b = -1;
    printf("%u %u", c, b);
    return 0;
}
```

上述代码打印结果为 4294967295 4294967295

1 为什么整数有那么多种？

- 为了准确表达内存，做底层程序的需要

2 没有特殊需要，就选择 int

- 现在的 cpu 字长普遍是 32 位或者 64 位，一次内存读写就是一个 int，一次计算也是一个 int，选择更短的类型不会更快，甚至可能更慢。
- 现代的编译器一般会设计内存对齐，所以更短的类型实际在内存中有可能也占据一个 int(虽然 sizeof 告诉你更小)

3 unsigned 与否只是输出的不同，内部计算是一样的。

## 3 浮点数

### 3.1 类型总览

| 类型   | 字节数 | 有效位数 | 输入(scanf) | 格式化输出(printf) |
| ------ | ------ | -------- | ----------- | ------------------ |
| Float  | 4      | 7        | %f          | %f                 |
| Double | 8      | 15       | %lf         | %f                 |

浮点数 2.4679999352，用 float 表示为 2.468000,只有七位有效，四舍五入后得到值。

### 3.2 科学计数法

%e %E

### 3.3 浮点数输出

```c
#include<stdio.h>
int main() {
    printf("%.3f\n", -0.0049);
    printf("%.30f\n", -0.0049);
    printf("%.3f\n", -0.00049);
    return 0;
}
```

输出结果为

-0.005
-0.004899999999999999841793218991
-0.000

其中 %.3f 表示小数点后留三位。计算小数时，计算机会对其值进行四舍五入。

### 3.4 超出范围的浮点数

+inf -inf nan

无穷大以及无穷小无法用整数来进行表示，他们同属于浮点类型。

### 3.5 浮点数的内部表达以及选择

1 浮点数不是真正的二进制数 2，而是编码的数

2 如果没有特殊需要，使用 double

- 现代 cpu 能直接对 double 做硬件运算，性能不会比 float 差，在 64 位的机器上，数据存储的速度也不会比 float 差。

## 4 字符类型

### 4.1 类型总览

Char 是一种整数，也是一种特殊的类型：字符。这是因为：

- 用单引号可以表示字符字面量: 'a', '1'
- ''也是一个字符
- printf 和 scanf 里用 %c 来输入输出字符

### 4.2 字符的输入和输出

```c
#include<stdio.h>
int main() {
    char c;
    int i;
    scanf("%c", &c);
    scanf("%d", &i);

    printf("c=%d\n", c);
    printf("c=%c\n", c);

    printf("i=%c\n", i);
    printf("i=%d\n", i);
}
```

执行上面代码，输入 1 49 ，输出如下

c=49
c=1
i=1
i=49

字符 '1' 转换成整数是 49, 整数 49 转换成字符是 '1'，计算机中字符是以 ascll 码方式进行存储的。其中 '1' 的 ascll 码是整数 49，'A' 的 ascll 码是整数 65。

### 4.3 混合输入

习题 a: 输入小写字母，输出大写字母

```c
#include<stdio.h>
int main() {
    int interval = 'A' - 'a';
    char c;
    scanf("%c", &c);
    printf("%c\n", c + interval);
    return 0;
}
```

### 4.4 逃逸字符

| \\" | "                                       |
| --- | --------------------------------------- |
| \\b | 回退一格                                |
| \\t | 制表符，每一行固定的位置                |
| \\  | /                                       |
| \\n | 换行(shell 中输出/n 默认会执行 /r + /n) |
| \\r | 回车                                    |
| \\' | 单引号                                  |

### 4.5 自动类型转换

当云算法的两边出现不一致的类型时，会自动转换成较大的类型。大的意思是能表达的数的范围更大。

char -> short -> int -> long -> long long

int -> float -> double

对于 printf,，任何小于 int 的类型会被转换为 int; float 会被转换成 double

但是 scanf 不会，要输入 short，需要 %hd, 输入 int, 需要输入 %d，输入 long long，需要输入 ld%

强制类型转换 （类型）值

比如 (int)3.2 (short)32

由于小的变量相对于大的变量所占的字节数少，所以小的变量不总能表达大的变量

如下代码所示：

```c
#include<stdio.h>
int main() {
    int a = 32768;
    printf("%d\n", (short)32768);
    printf("%d", (char)32768);
    return 0;
}
```

输出为

-32768
0

强转 short 类型, short 最大为 32767,加 1 溢出变成 -32768

强转 char 类型，char 为 一个字节。精度缺失，变成 0

## 5 布尔类型

```c
#include<stdbool.h>
int main() {
  bool a = true;
  printf("%d", a);
}
```

布尔类型，如果用 printf 进行打印，显示的是 0 或 1。

## 6 条件运算

如果获取 (4,6)区间之间的值呢？

```c
#include<stdio.h>
int main() {
  int x;
  sccanf("%d", &x);
  if(4<x<6){
    // 错误写法。 先计算 4 < x,得到 1 或者 0，然后再与 6 进行比较。得到的结果始终为1
  }

  if(x>4 && x < 6) {
    // 这是正确的
  }
}
```
