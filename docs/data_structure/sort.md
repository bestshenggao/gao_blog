# 排序算法

## 1. 选择排序

n 个数排序 n-1 次找最小值的过程，即先找 n 个数里面的最小值，再找剩余 n-1 个数值里面的最小值，再找剩余 n-2 个里面的最小值，。。。。。。 最后找剩余两个数里面的最小值，剩余一个数就是 n 个数里面的最大值。

由此可知， n 个数的选择排序是一个两重循环的问题：外层循环控制求最小值的次数，n-1 次求最小值由 n-1 次外循环实现，假设外循环变量为 i, 则 i 的循环范围为 0 ~ n-2; 内层循环完成求一个最小值的过程，假定当前元素 a[i] 是最小值假设内循环变量为 j, 让 a[i] 与其后的所有元素 a[j] 逐个比较，j 的范围即为 i+1 ~ n-1

对于以下这样的10个数字的排列，按照上述的排序方法，程序在执行中，元素 a[0] 依次与后面的 a[1]、。。。。。。a[9]相比较，每次 a[0] 都比后面的数字大，每次比较都要做交换，而这还仅仅是找一次最小值的过程。如果元素比较多时就会有大量的多与交换存在，影响程序的执行效率。于是程序可以进行改造：

每一次找最小值只需要一次交换，即初始位置与最小值元素做交换。在外层循环控制求最小次数的过程中，定义一个变量 min, 赋初值为当前的初始变量的下标 i, 在内层循环找最小值的过程中，如果发现当前元素的值比初始变量的值小，则将新的最小值的下标赋予 min。内层循环一趟结束，找到最小值后，判断 min 值是否发生了变化，变化了则进行位置交换，否则不需要交换。

```c
int a[10] = {10,9,8,7,6,5,4,3,2,1}; 
```

```c
#include <stdio.h>
int a[10] = {2, 1, 4, 5, 3, 6, 7, 8, 9, 10};

void main()
{
    int i, j, k, min, n = 10;
    for (i = 0; i <= n - 2; i++)
    {
        min = i;
        for (j = i + 1; j <= n - 1; j++)
        {
            if (a[i] > a[j])
            {
                min = j;
            }
        }
        if (min != i)
        {
            k = a[min];
            a[min] = a[i];
            a[i] = k;
        }
    }
    for (i = 0; i <= n - 1; i++)
    {
        printf("%d ", a[i]);
    }
}
```

## 2. 冒泡排序

冒泡排序也是通过 n-1 次找最大值的方式实现排序的，但它找最大值的方式与选择排序不同

冒泡排序找最大值的方式是从第一个元素开始与每相邻的两个元素进行比较，如果前面的数据小于后者，则两者交换，如此一直比较到当前序列的最后一个位置。

冒泡排序也是一个双重循环：

1. 外层循环控制找最大值的次数，既然是 n-1 次求最大值的过程，所以用 n-1 次外循环实现，假设外循环变量为 i，则 i 的循环范围为 0 ~ n-2。
2. 内循环完成求一个最大值的过程，内循环是在 a[0],a[1]...a[n-i-1]的数组元素范围内找到最大值，并放在当前区间的最后元素a[n-i-1]中。假设内循环变量为 j，则 j 的范围为 0~n-i-2。

```c
#include <stdio.h>

int a[11] = {11, 5, 4, 3, 2, 1, 7, 8, 10, 9, 6};
int length = 11;

void main()
{
    int i, j, temp;
    for (i = 0; i <= length - 1; i++)
    {
        for (j = 0; j <= length - 1 - i; j++)
        {
            if (a[j] > a[j + 1])
            {
                temp = a[j];
                a[j] = a[j + 1];
                a[j + 1] = temp;
            }
        }
    }
    for (i = 0; i <= length - 1; i++)
    {
        printf("%d ", a[i]);
    }
}
```
